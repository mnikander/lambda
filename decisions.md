|Num| YYYY-MM-DD | Superseded by | Project    | Tags        | Decision                                                 | Rationale |
|---| ---        | ---           | ---        | ---         | ---                                                      | --- |
|001| 2025-04-06 |               | lambda     | @pm         | create a separate repository for the language spec       | Single source of truth for multiple implementations. Avoids duplicate documentation. Easy to version, reference, and maintain. |
|002| 2025-04-06 |               | lambda     | @pm         | document things in the most compact form                 | Easy to maintain. Working software is the primary measure of progress. Out of date documentation is worse than no documentation. |
|003| 2025-04-06 |               | lambda     | @pm         | markdown is the main format of documentation             | Can be viewed on GitHub directly. Simple. Works well with version control. Easier to write than Sphinx documentation. |
|004| 2025-06-06 |               | lambda     | @pm         | document core feature set in the README                  | The README is the first page you see when you open the repository on GitHub. It is good if the high level overview and the single-source of truth is right there. |
|005| 2025-04-06 |               | lambda     | @pm         | document language features in a table of type signatures | Easy to maintain. Fits on a single screen. Easy to search. Brainstorming or details and discussion can be placed in other markdown files and linked directly in the table. |
|006| 2025-04-06 |               | lambda     | @pm         | document design decisions in a table                     | WHY something was done in a particular way is super important to allow understanding and revising decisions later on. Design documents proved to be out of date too quickly and too time-consuming. |
|007| 2025-04-06 |               | lambda     | @pm         | document design decisions of all projects in one file    | Keeps implementation repositories focused on the code. It's easier to find decisions if they are all in one place. The project and tag fields should allow searching effectively. |
|008| 2025-04-06 | 009           | lambda     | @pm         | ~~omit file extension on decision file~~                 | Easy to open in a spreadsheet program to search and edit. Hopefully GitHub will still recognize it as Markdown and render it as such. |
|009| 2025-04-06 |               | lambda     | @pm         | .md file extension on decision file, instead of none/CSV | GitHub needs the .md file extension to render it as markdown. Probably I will use the GitHub preview more often than a spreadsheet. |
|010| 2025-04-06 |               | lambda     | @pm         | split the single lambda project into many small projects | Separation of concerns on the project level. Smaller scope. No interactions between features. Much easier to experiment with language features. Allows re-implementating the core to gain experiece. |
|011| 2025-04-14 |               | lambda     | @pm         | release version 1.0.0 once there is a working prototype  | There is no benefit in releasing the spec before there is a working prototype. Problems with the core and the table of signatures will be found. Re-releasing the spec would just be extra work. |
|012| 2025-04-06 |               | lambda     | @lang       | use symbolic expressions like Lisp                       | Easy to lex and parse. Parentheses may negatively impact readability but also make the syntax homogeneous, simple, and easy to extend. |
|013| 2025-04-11 |               | lambda     | @lang       | define a small language Core and optional Extensions     | Decrease initial implementation effort for an interpreter or compiler. Can experiment with the Core and just one Extension at a time. Faster experimentation than with one large codebase which tries to implement everything. |
|014| 2025-04-13 |               | lambda     | @mem        | pass-by-reference implicitly, move explicitly via keyword| Decreases the WTFs/minute. This is what most people are used to, from C++ to Haskell programmers. Most functions will probably reference values. The less common and less intuitive option, destructive move, requires a keyword. |
|015| 2025-04-13 | 042           | lambda     | @mem @clos  | ~~closure is a separate construct, disjoint from lambda~~| ~~Since closures store their captured values, ownership and lifetimes need to be specified. This is best done with a specific notation, different from normal lambda/function definitions, to avoid confusion. Makes it possible to add closures as a separate feaure later. They need to be treated like any other function.~~ |
|016| 2025-04-13 |               | lambda     | @mem @clos  | closure captures by reference implicitely                | Since the default is pass-by-reference (see decision #103), it makes sense that it's the same for closures. Capture-by-move requires the keyword `move` explicitly. |
|017| 2025-04-13 |               | lambda     | @mem @clos  | closure must list all captures explicitly                | Avoids accidental captures. Forces programmers to think abount what to capture by reference and what to capture by move. Makes it clear that capturing has costs. |
|018| 2025-04-14 | 021           | lambda     | @lang       | ~~'Identifier' is a production of 'Expression' not 'Atom'~~ | This deviates from Lisp. The parser and AST node for the Atom become simpler this way, because atoms can only be primitive datatypes. |
|019| 2025-04-14 |               | lambda     | @type       | Add the unit type to the grammar                         | The naming is consistent with category theory and doesn't collide with conventions from other languages. This is the equivalent of the `void` type in C. |
|020| 2025-04-14 |               | lambda     | @lang       | Allow `fn` keyword to define anonymous functions         | `fn` is approachable for beginners. `lambda` is long and may be intimidating for people unfamiliar with lambda expressions. The arrow `->` is very nice but does not stand out in functions which use `>`. There are no plans to have anything other than lada functions and closures, both of which will be anonymous, so the `fn` keyword is available. |
|021| 2025-04-20 |               | lambda     | @lang       | 'Identifier' is a production of 'Atom'                   | Consistent with Lisp convention. Once integer and boolean literals are in place, the 'Atom' is a non-terminal production anyway, so it might as well have Identifiers as one of its terminal productions. Keeps the 'Expression' rule a bit cleaner. |
|022| 2025-05-04 |               | interpreter| @arch       | Separate semantic and evaluation environments            | Clear separation of concerns. Involves some duplication of function names for built-in functions, but makes it easier to add type information later, and makes it easier to have multiple backends (i.e. TS evaluator versus C++ code generator) |
|023| 2025-05-06 |               | interpreter| @arch       | Let-bindings are normal 'identifier' tokens              | Keeps the tokenization simple, uniform, and leaves the door open for macros. I'm not sure if this decision was really such a good one. Making the distinction in the tokenization would have a more consistent style with the rest of the codebase. |
|024| 2025-05-06 |               | interpreter| @arch       | Let-bindings have their own node type in the AST         | Separation of concerns. Let-bindings are not a normal function call. It is a special form, and interacts with both the semantic and evaluation environments, which no function does. Separate implementations allow separate refactoring. |
|025| 2025-05-06 |               | interpreter| @arch       | Let-bindings are checked in parsing not semantic analysis | The structure of let-bindings is very specific, and it makes sense to check the number of arguments while building the node, so that invalid AST constructions are avoided. |
|026| 2025-05-23 |               | lambda     | @type       | Public API of modules must have explicit type signatures | If the entire public API of a module has explicit type signatures, then type deduction and type checking can be done individually for each module. This improves error messages, allows massively parallelized type checking, and speeds up recompiles. |
|027| 2025-05-28 |               | interpreter| @arch       | binding ID must be unique for each bound variable        | If each variable has a unique binding ID, that ID can be used to quickly look up references and meta-data during compilation. |
|028| 2025-06-04 |               | interpreter| @arch       | binding ID is a pair of numbers                          | It is useful to bind several variables at once, in a lambda or let-binding. The binding ID must clarify which binding is meant. A pair of IDs, as opposed to just one node ID, is an easy way to do this.|
|029| 2025-06-04 |               | interpreter| @arch       | resolve references once, to a unique binding id          | Separation of concerns. Single implementation for reference-resolution. Avoids difficult bugs if reference-resolution implementations misalign over time. |
|030| 2025-06-04 |               | lambda     | @lang @mem  | data is immutable                                        | Simplifies reasoning about code. Completely avoids complicated checks necessary for mutable references.|
|031| 2025-06-04 |               | lambda     | @mem        | cons cell based lists are always owned by the root node  | Clear ownership model. Avoids the overhead of reference-counting. The borrow checker ensures that you don't use-after-free. You cannot directly do partial frees in this model, but 3estructive move / destructive update would effectively enable it.|
|032| 2025-06-04 |               | lambda     | @mem        | no shared pointer                                        | Focus on move-based single ownership for now, to keep things simple. Data is immutable, so all references (borrows) are read-only and you can have as many of those as you want without runtime reference counting in a shared pointer.|
|033| 2025-06-04 |               | lambda     | @mem        | copy always does a deep copy                             | Avoids shared ownership. Makes `copy` an unambiguous operation and makes it easy for the compiler to generate it automatically. |
|034| 2025-06-04 |               | lambda     | @lang @mem  | move, copy, borrow, and destroy are compiler-generated   | User-generated copy or destructor functions could break the lifetime and borrowing model. The compiler can generate them automatically by recursively calling the respective functions on each constituent of a data-structure. |
|035| 2025-06-04 |               | lambda     | @mem        | assume worst-case lifetimes for return values with references| If borrowed inputs _must_ live longer than borrowed outputs, then manual lifetime annotations are not needed. Avoids cluttering the code. Programmers could split code into separate functions to avoid unwanted lifetime requirements.|
|036| 2025-06-04 |               | interpreter| @arch       | use separate symbol tables for lifetimes and type checks | Separation of concerns. Easier to test. Keeps the codebase modular. Makes it easier for others to understand and re-use my code in their own projects. |
|037| 2025-06-05 |               | lambda     | @lang       | only support unary lambda expressions at first           | It's easier and sufficient to focus on unary lambdas initially. Supporting multiple arguments requires extending the grammar to include brackets for lists, and would also make the implementation of lambda evaluation more complex due to more cases. |
|038| 2025-06-05 |               | lambda     | @lang       | do not support nilary lambda expressions at first        | Addendum to decision #037. Focus the implementation on a single case: unary lambdas. Typically, nilary functions are only used for side-effects, which are not as relevant in the early stages of prototyping the memory model. |
|039| 2025-06-06 |               | lambda     | @lang       | base the entire evaluation logic on curried unary lambdas| Keeps semantic analysis (type-checking) and evaluation simple. Only one case to deal with. I can add de-sugaring of multi-argument functions later. This might make transpilation to efficient C++ code much more difficult though. |
|040| 2025-06-06 |               | interpreter| @arch       | use de Bruijn indices for lambda arguments               | Simple substitution scheme for variable names. Allows stack-based evaluation of lambda expressions. Avoids naming conflicts by resolving all name statically. |
|041| 2025-06-06 |               | interpreter| @arch       | use stack-based evaluator for lambdas                    | Simple and very fast. Much better for my use-case than a slow and complicated name-based lookup. |
|042| 2025-06-06 |               | interpreter| @arch       | implement closures with stack slices                     | Closures enable partial function application and higher-order functions. Implementation based on stack-slices is fast. Fits well with the chosen evaluation model. |
|043| 2025-06-06 |               | lambda     | @lang       | use applicative order (not normal order) evaluation      | Applicative order (call-by-value) is much simpler to implement than normal order (call-by-name) and Haskell's call-by-need. It's also very fast in cases which don't loop forever. Dead-code-elimination and constant-inlining mitigate some problems.|
|044| 2025-06-06 |               | interpreter| @type       | differentiate between values and arrows                  | A simplified version of Simply Typed Lambda Calculus. Less work to implement initially, and can at least catch function over-application errors (too many arguments). Can be expanded to simply typed lambda calculus afterwards. |
