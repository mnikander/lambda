|Num| YYYY-MM-DD | Superseded by | Project    | Tags        | Decision                                                 | Rationale |
|---| ---        | ---           | ---        | ---         | ---                                                      | --- |
|001| 2025-04-06 |               | lambda     | @pm         | create a separate repository for the language spec       | Single source of truth for multiple implementations. Avoids duplicate documentation. Easy to version, reference, and maintain. |
|002| 2025-04-06 |               | lambda     | @pm         | document things in the most compact form                 | Easy to maintain. Working software is the primary measure of progress. Out of date documentation is worse than no documentation. |
|003| 2025-04-06 |               | lambda     | @pm         | markdown is the main format of documentation             | Can be viewed on GitHub directly. Simple. Works well with version control. Easier to write than Sphinx documentation. |
|004| 2025-06-06 |               | lambda     | @pm         | document core feature set in the README                  | The README is the first page you see when you open the repository on GitHub. It is good if the high level overview and the single-source of truth is right there. |
|005| 2025-04-06 |               | lambda     | @pm         | document language features in a table of type signatures | Easy to maintain. Fits on a single screen. Easy to search. Brainstorming or details and discussion can be placed in other markdown files and linked directly in the table. |
|006| 2025-04-06 |               | lambda     | @pm         | document design decisions in a table                     | WHY something was done in a particular way is super important to allow understanding and revising decisions later on. Design documents proved to be out of date too quickly and too time-consuming. |
|007| 2025-04-06 |               | lambda     | @pm         | document design decisions of all projects in one file    | Keeps implementation repositories focused on the code. It's easier to find decisions if they are all in one place. The project and tag fields should allow searching effectively. |
|008| 2025-04-06 | 009           | lambda     | @pm         | omit file extension on decision file                     | Easy to open in a spreadsheet program to search and edit. Hopefully GitHub will still recognize it as Markdown and render it as such. |
|009| 2025-04-06 |               | lambda     | @pm         | .md file extension on decision file, instead of none/CSV | GitHub needs the .md file extension to render it as markdown. Probably I will use the GitHub preview more often than a spreadsheet. |
|010| 2025-04-06 |               | lambda     | @pm         | split the single lambda project into many small projects | Separation of concerns on the project level. Smaller scope. No interactions between features. Much easier to experiment with language features. Allows re-implementating the core to gain experiece. |
|101| 2025-04-06 |               | lambda     | @lang       | use symbolic expressions like Lisp                       | Easy to lex and parse. Parentheses may negatively impact readability but also make the syntax homogeneous, simple, and easy to extend. |
|102| 2025-04-11 |               | lambda     | @lang       | define a small language Core and optional Extensions     | Decrease the initial implementation effort for an interpreter or compiler. Allows individual coding projects to experiment with the Core and just one Extension at a time. Allows faster and easier experimentation that one large codebase which tries to implement everything. |
|103| 2025-04-13 |               | lambda     | @mem        | pass-by-reference implicitly, move explicitly via keyword| Decreases the WTFs/minute. This is what most people are used to, from C++ to Haskell programmers. Most functions will probably reference values. The less common and less intuitive option, destructive move, requires a keyword. |
|104| 2025-04-13 |               | lambda     | @mem @clos  | closure is a separate construct, disjoint from lambda    | Since closures store their captured values, ownership and lifetimes need to be specified. This is best done with a specific notation, different from normal lambda/function definitions, to avoid confusion. Makes it possible to add closures as a separate feature later. They need to be treated like any other function. |
|105| 2025-04-13 |               | lambda     | @mem @clos  | closure captures by reference implicitely                | Since the default is pass-by-reference (see decision #103), it makes sense that it's the same for closures. Capture-by-move requires the keyword `move` explicitly. |
|106| 2025-04-13 |               | lambda     | @mem @clos  | closure must list all captures explicitly                | Avoids accidental captures. Forces programmers to think abount what to capture by reference and what to capture by move. Makes it clear that capturing has costs. |
|107| 2025-04-14 |               | lambda     | @lang       | 'Identifier' is a production of 'Expression' not 'Atom'  | This deviates from Lisp. The parser and AST node for the Atom become simpler this way, because atoms can only be primitive datatypes. |
|108| 2025-04-14 |               | lambda     | @lang       | Add the unit type to the grammar                         | The naming is consistent with category theory and doesn't collide with conventions from other languages. This is the equivalent of the `void` type in C. |
